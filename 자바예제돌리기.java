import java.util.Arrays;
import java.util.Scanner;

public class 자바예제돌리기 {
	public static void main(String[] args) {

			
		String[][] ex = { { "구조적 프로그래밍 설계구조를 적으시오(3개)", "순차 구조", "선택 구조", "반복 구조" },
				{ "구조적 프로그래밍 설계서 구성요소를 모두 적으시오(4개)", "데이터 흐름도", "자료 사전", "상태 전이도", "소단위 명세" },

				{ "구조적 프로그램 설계서 구성요소 중 각 기능을 분할하여 표현.데이터 이동을 보여줌", "데이터 흐름도" },
				{ "구조적 프로그램 설계서 구성요소 중 자료 저장소를 구체적으로 명시하기 위해 사용하는 도구", "자료 사전" },
				{ "구조적 프로그램 설계서 구성요소 중 어떤 상태에서 다른 상태로 변경되는 과정 및 해당 과정의 프로세스 명세를 작성", "상태 전이도" },
				{ "구조적 프로그램 설계서 구성요소 중 나눌 수 없는 부분까지 기능을 분리하여 작성한 명세서.구조 언어를 사용하거나 N-S Chart를 이용", "소단위 명세" },

				{ "데이터흐름도  DFD의 구성요소를 모두 적으시오(4개)", "프로세스", "데이터 흐름", "데이터 저장소", "외부 엔티티" },
				{ "DFD 구성요소 중 원으로 표현", "프로세스" }, { "DFD 구성요소 중 화살표로 표현", "데이터 흐름" },
				{ "DFD 구성요소 중 두 개의 직선인 평행선으로 나타냄", "데이터 저장소" }, { "DFD 구성요소 중 사각형 형태로 표시", "외부 엔티티" },

				{ "구조적 프로그래밍 유형 중 미국의 벨 연구소.이식성이 좋다.고급언어와 저급언어의 특성을 동시에 가짐", "C언어" },
				{ "구조적 프로그래밍 유형 중 문법이 간결하면서도 사용하기가 편리", "파스칼" },
				{ "구조적 프로그래밍 유형 중 높은 신뢰도를 갖고 장시간 운용 가능한 대규모 시스템을 구성하기 위한 컴퓨터 프로그래밍 언어 ", "에이다" },

				{ "기능적 모듈화를 고려하는 것 중에 서로 연관되어 있는 정도. 강할수록 품질이 높고, 약할수록 품질이 낮음", "응집도" },
				{ "기능적 모듈화를 고려하는 것 중에 서로 의존하는 정도. 강할수록 품질이 낮고, 약할수록 품질이 높음", "결합도" },

				{ "반복문의 일종으로 최소 한번은 수행하고, 참일 때만 반복적으로 수행한다는 점에서 while 반복문과 다르다.", "do while 반복문" },

				{ "객체지향 프로그래밍 설계에서 객체지향 속성 4가지를 적으시오(4개)", "캡슐화", "상속성", "추상화", "다형성" },
				{ "객체지향 속성 중 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 기법", "캡슐화" },
				{ "객체지향 속성 중 어떤 실체로부터 관심 있는 특성들만 모은 것", "추상화" }, { "객체지향 속성 중 같은 모양의 함수가 상황에 따라 다르게 동작", "다형성" },
				{ "객체지향 속성 중 부모 클래스에 새로운 기능을 추가해 자식 클래스를 만들어 사용하는 기법", "상속성" },

				{ "객체지향 프로그래밍 설계에서 객체지향 설계원칙을 순서대로 적으시오(5개)", "단일 책임원칙", "개방 폐쇄원칙", "리스코프 치환원칙", "인터페이스 분리원칙",
						"의존 역전원칙" },
				{ "객체지향 설계 원칙 중 모든 클래스는 각각 하나의 책임만", "단일책임원칙" },
				{ "객체지향 설계 원칙 중 기존의 코드를 변경하지 않고(closed),기능을 추가할 수 있도록(open)", "개방 폐쇄원칙" },
				{ "객체지향 설계 원칙 중 자식 클래스는 자신의 부모 클래스를 대체할 수 있다는 원칙.부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 작동해야 한다.", "리스코프  치환원칙" },
				{ "객체지향 설계 원칙 중 하나의 평범한 인터페이스보다 여러 개의 구체적인 인터페이스가 좋음", "인터페이스분리원칙" },
				{ "객체지향 설계 원칙 중 변화가 없는 것에 의존해야 한다는 원칙.구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 하는 원칙.", "의존 역전 원칙" },

				{ "UML의 이해 중 요구 분석, 시스템 설계, 시스템 구현 등의 시스템 개발 과정에서, 개발자 간의 의사소통을 원활하게 이루어지도록 표준화한 객체지향 모델링 언어",
						"유즈케이스다이어그램" },
				{ "UML의 이해 중 클래스 내부 구성요소 및 클래스간의 관계를 도식화한 다이어그램", "클래스 다이어그램" },
				{ "UML의 이해 중 객체 간의 상호작용 메시지 시퀀스를 시간의 흐름에 따라 나타내는 다이어그램", "시퀀스 다이어그램" },
				{ "(클래스다이어그램 중)보통 명사형으로 많이 표현되며 실제 구현된 클래스를 기준으로 (이것)은 클래스의 맴버 변수로 사용된다. ", "속성" },
				{ "(클래스다이어그램 중)다이어그램에서 가장 하단에 위치하고 있으며 해당 클래스가 수행할 수 있는 (이것)들을 가진다. ", "행동" },
				
				{ "시퀀스 다이어그램 중 객체 라이프라인을 가지는 것", "활성객체" },
				{ "시퀀스 다이어그램 중 자신의 객체 라이프라인으로부터 다른 객체 라이프라인까지 선+화살표로 표시", "메시지" },
				{ "시퀀스 다이어그램 중 객체 라이프라인 위에 그려지는 박스.객체의 특정 메소드가 실행되고 있다는 것을 나타냄.", "활성박스" },
				{ "객체지향 프로그래밍 언어 구성요소(4개)", "클래스", "객체", "메서드", "속성" },

				{ "화면 설계서 유형 중 기획 단계에서 페이지 레이아웃이나 화면 이동 등을 기술한 문서", "와이어프레임" },
				{ "화면 설계서 유형 중 와이어프레임의 내용에 디스크립션 등을 포함", "스토리보드" }, { "화면 설계서 유형 중 설계 단계에서 실제 화면과 같은 형태의 모형", "목업" },
				{ "화면 설계서 유형 을 모두 적으시오.(3개)", "와이어프레임", "스토리보드", "목업" },

				{ "다음 설명이 의미하는 것은? : 객체지향 프로그래밍 시 발생하는 여러 가지 문제에 대한 설계 사례를 분석하여 공통적으로 발생하는 문제를 해결하기 위한 방법론으로, 여러 설계들로 분류 하고, 각 문제 유형"
						+ "별로 가장 적합한 설계를 일반화한 패턴이다", "디자인 패턴" },
				{ "다음 설명이 의미하는 것은? : 디자인 패턴 중 23가지의 디자인 패턴이 정리되어 있고, 구현 방식에 따라 생성, 구조, 행위 3가지로 분류한다.\r\n"
						+ "대표적인 예시로 Singleton이 있다.", "GoF디자인 패턴" },

				{ "스크립트 프로그래밍 순서를 적으시오(4개)", "스크립트 코드작성", "ByteCode변환", "기계어 변환", "CPU코드 실행" }, // i 0~42개

		};

		
		System.out.println("정답을 적을때는 띄어쓰기를 쓰지 마시오");
		System.out.println("여러개의 정답을 적을때는 , or 빈칸을 써서 답을 구분 하시오");
		Scanner sc = new Scanner(System.in);

		int[] arr = new int[ex.length];
		int o = 0; // 정답 개수

		int[] rightAnswer = new int[ex.length]; // 문제 개수만큼 0이들어간 배열 쭉 일단 만들어둠 -> 맞았을 때, 그 정답 번호의 값이 1로 바뀜

		while (true) {

			for (int i = 0; i < ex.length; i++) { // i : 문제번호
				
				if (rightAnswer[i] == 0) {
					System.out.println("Q" + (i + 1) + " " + ex[i][0]);
					String input = sc.nextLine();

					input = input.replace(" ", "/");
					input = input.replace(",", "/");
					input = input.replace("-", "");

					while (input.contains("//")) {
						input = input.replace("//", "/");
					}
					String[] inputArr0 = input.split("/");

					String[] answerArr = new String[ex[i].length - 1];
					String[] inputArr = new String[ex[i].length - 1];
					for(int j=0; j<=inputArr.length-1; j++) {
						inputArr[j] = ""; // null 빈 문자열로 바꿈
					}
					for(int j=0; j<=inputArr0.length-1; j++)
						
						try {
							inputArr[j] = inputArr0[j];
						} catch (Exception e) {
							
						}
					
					
					for (int j = 0; j <= answerArr.length - 1; j++) {
						answerArr[j] = ex[i][j + 1].replace(" ", "");
					}
					// System.out.println(Arrays.toString(inputArr));
					// System.out.println(Arrays.toString(answerArr));

					// 핵심코드
					int count = 0;
					for (int j = 0; j <= (ex[i].length - 1) - 1; j++) {
						for (int k = 0; k <= (ex[i].length - 1) - 1; k++) {
							if (inputArr[j].equalsIgnoreCase(answerArr[k])) {
								count++;
								break;
							}
						}
					}
					if (count == ex[i].length - 1) { // 모두 맞춘 것!
						System.out.println("모두 정답");
						System.out.println();
						o++;
						rightAnswer[i] = 1;

					} else {
						System.out.print("오답. 정답은 : ");
						System.out.println(Arrays.toString(answerArr));
					}

				} // if문

			} // for문

			if (o >= 42) {
				System.out.println("준비된 오답이 없습니다.");
				break; // 종료
			}
			
			System.out.println("오답들만 다시 시행됩니다.");
		} // while

	} // MAIN

}
